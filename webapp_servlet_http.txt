--As we disscused earliear that java comes in 3 flavour:-

1.J2SE -standard or base edition 

2.J2EE--Enterprise edition

3.J2ME---Micro edition

all r the specification and the implementaions are:-

J2SE--JDK s/w

J2EE --Application S/w


Enterprise App:- All enterprises need computer application to provide thier services throught the
world. those kind of application we called as a EA.


--B.app logically divide into 3 logical partion :-

PL BLL DAL DL

--we already discuses about the architecture of and EA,and EJB and ApplicationServer,

--ApplicationServer has 2 container 

1.EJB-container 

2.Web-Container



--with the Spring we don't require the EJB container,we just need a webcontainer

Diff bt ApplicationServer and WebServer


1.Webserver is a small part of a ApplicationServer which has only one container,-webcontaner or Servlet container.

2.with AS we can communicate with any type of Protocol,but with the WebServer we can communicate only through http protocol.


Web-Application:-
----------------

--the application what we can access through web,more specifically through http protocol is known as a web-application

--A web-app basically contains web-component or webresources like html file,image files,Servlet program,jsp program etc..

--each web-resource program is capabale of generating one web-page.


--the web-pages r also divided into 2 types:-

1.static web-page:- whose content is fixed always for each client,ex:- home page of a gmail.

--the webresource program that can generate a static-webpage is called static-webresource

ex:- html file,image files etc.


2.Dynamic web-page:- whose conntent chages dynamically based on input values of the client.ex:- inbox of gmail.

--the webresource program that can generate dynamica webpage having dynamic content r called dynamic web-resource ex:- Servlet program,jsp program.


--so a web-application is collection of both static and dynamic webresource prog.
--web-app resides in a web-server. 



Web-client:-
------------

--resource sake request making program is known as client.

--in web-env,the program which make request to our web-appl through http protcol is known as web-client or Http-Client or User-agent. 

--generally its browser s/w. from where we make request through http protocol.

--we can generate the http request from our java app as well,and also we have certain  other programs r there by which we can generate http request like PostMan.


--basically when we generate a http req,we get the http response from that web-app.

--this http response generally contains html text based on our request,that html text will be rendered in the browser and browser displays the html content.this type of appl is known as normal web-application.


--there r another type of web-application which generates the data not the view,so when the client gives the request to that web-application ,that application does not give view(html text) as response instead it gives data in the form of plan text,json,xml as http response.this type of web-application is known as web-services.

--ie. services runing over the web,where client can gives the http request and gets the http response.




WEB-SERVER:-
------------

---it is a  resource dilevering s/w to web-client.

it is a piece of s/w which can listen to client request continiously.it manages 
web-resources and executes Web resoureces dynamically and automatically,when they 
are requested by client.then it collects results given by web-resource programs and sends
result to client as HTTP response.

---the neccesary environment to execute dynamic web-resourse will be supplied by web-
server s/w.

--we can think a webserver is a subset of an AS which has only one container called servlet container. 

--web-server supports only http protocol.



Http-Protocol:-
--------------

---HTTP is a protocol that contains set of rules and guideline to get the communication b/w 
http client (browser window) and web-server ie to transfer hypertext or data
between http-client and webserver.






HTTP Request Structure:-
---------------------------
Http Request is generated by client(browser window) to pass the request to a Web-resourse 
of the web-application.
--This request contains lot of details based on certaian structure.


HTTP Request Method(GET,Post,....etc).
Path of requested web resource(Helloworld/A.html)
HTTP request Headers//from slide.
(Request body where parameter or Query String:-ie,sno=100 &sname=rama are passed.

1.initial request line(1.request method,2.request uri,3.protocol/version)
ex(1.GET,2./x.html,3.HTTP/1.1)(2.0 version relesed in 2015)
2.Headers
3.Body

Http headers:-
-------------

Date:---on which date and time request has made

Host:- request sender ip address

user-agent:- from which browser/client request has come

cache-control:whether suporting cache or not

Connection:--whether connection is live or lost

Content-type:-which kind of request has come(normal html or JSON/XML ..)

coockie:- wheater any coockie value is comming or not.



---http body:-
--------------

generally data that comes by the post/PUT/DELETE method,will goes to the server by using http body






HTTP Response Structure:-

each Http Response comming to browser contains lots of details in the form
of certain structure.

1.resonse Status code.
2.Response Header.
3.response content/response body


1.initial response line(1.status code,2.status description,3.protocol/Version)
ex(1.200,2.OK,3.Http/1.1)
2.Response Header.
3.Response body.

Status code:-

100-199---information.
200-299---success.
300-399---Redirection.
400-499---Incomplete webresource/Bad request.
500-599---Server-error.

--generally webserver sets the status code for each response.
--default status code is 200.

Response Header:-

-name of this header are fixed,and the values to this header is assigned by webserver
or developer,these headers carry additional information to the client to guide the 
client while displaying response content as webpage on b/w window or in the application.

some headers names are:-

server-
refresh-
set-cookie,
last-modified,
accept-range,
content-type,
content-length,
date
connection


Respone body:-

--it contains the dynamic html text or some dynamic data in the form of plan text/json/xml form.




Request Parameter:-
-------------------

data that are passed from browser for processing by server side program is known as
request parameter.

--it is also known as Query parameter

--Request parameters are name value pairs.ie every data that is passed to the server
side program for processing must have name and value.
ex-t1=rama. this name value pair is called as an query string.

--if there are more than one request parameter are there then all request parameter are
concateneted with & symbol
ex-t1=rama&pass=1234.

--we pass request parameter from browser to server by 4 ways
1.by typing to the url (as query string).
1.through hyperlink--it uses get method and goes as a query string.
2.through get()---go with url
3.through post()--go with http req body



Path Parameter :- 
---------------

--this data is supplied with key,and by using uri/

--this data we access inside the webservices through @PathParam annotation.




limitation of Appserver or WS:-
-------------------------------
if we use only As or WS to support a WA that App can be only informative but can not be 
intractive.

---A WA is said to be intractive if it is responding to the end user's input  
---A AS  or WS can recieve end user's input sent by the client,but it cannot process 
data,
--it can not intract with the database server,it cannot produce response page dynamically
--All these functions are mandatory for an intractive WA.


---static webresources are precreated (before client req come)
--static WR genetreted WP content remain same with user intraction.

---Dynamic WR are not precreted 
ie Dynamic WR genereted WP content changes with user intraction,based on input value
passed by user.




-----A WA program is classified in two categories:-

1.client side program
2.Server side program


Client-side programming:-
------------------------
--this program executes in the client machine.. 
--In WA context java-Script code is known as Client side programming.
--developing java-script code that perform client side validation is known as CLP.
--to inforce the end-user to enter complete and proper input into the WPage,
validation is used...



Server-side programming:-
--------------------------
---A program that is executed at web-server is known as serverside program.

--with the help of server side program we overcome the limitation of WS or AS.
ie.making WA intractive...


---A server-side program does the following things in general:-

1.capturing the user input.
2.if necessary communicating with DB.
3.process the Data.
4.producing the dynamic page based on the processed data and handle over this 
dynamic page to WS or AS then WS or AS forward that page to the client...







Servlet:-
---------


--it is a server-side java based technology to develop a dynamic web resources program,having ability to extend the functionality of ws .


---Servlet is a speci (sub-speci )of jee that contains rules and guidelines to develop servlet container s/w .

--it provides api to develop a servlet webresoures program.

Servlet Api:-

javax.servlet package:-
javax.servlet.http package.




A Servlet:-
-----------

--it is a web-component that generate web-page dynamically.

--it is a web-container managed public java class that implements 
javax.servlet.Servlet interface.and override all five methods of Servlet Interface

methods in servlet Interface:-

1.ServletConfig getServletConfig();
2.void init(ServletConfig sc)throws SE
3.void service(ServletRequest req,ServletResponse res)throws SE,IOE
4.String getServletInfo();
5.void destroy();

--here 3 are life-cycle method and two are inLine method..

--Method service() contains the algorithm to generate dynamic web-page.




Steps to write a Servlet Program by implementing Servlet Interface:-
-------------------------------------------------------------------

step1:- create a public java class by implementing Servlet Interface.

step2:- override all five methods defined in Servlet Interface.

step3:-write all dynamic web-page logic in service() method.

step4:-register that java class in DD file in this case it is web.xml

Note:-the class that is acting our Servlet program must be taken as public class 
then only Web-container can locate and create our servlet class Object.

--A Servlet class should not have only paramiterrized constructor.

Note:- creating object of Servlet class,managing that class object,destroying that
object and executing life-cycle methods on that object is not the responsibilty 
of programmer. All these operation will be taken care by Web-Container 



application/pdf

Life cycle of a servlet:-


1.whenever Web-container recieve the first client request for a servlet,
Webcontainer loads the servlet class into primary memory dynamically and creats
the object of the loaded class by calling zero argum constructor.

---here servlet insance is ready but it cannot serve the client request bcoz at this
stage it is missing with two piece of information...


1.initial configuration information.

2.Context information.


--configuration information about a servlet is written in DD file(web.xml)

---to get these two piece of information Web-Container Creates ServletConfig object

and in this object Web-container encapsulates above two missing information..


---now Web-container call first life cycle method on our servlet class object ie,
init(ServletConfig cg)by supplying ServletConfig object refference as argument..

Note:- untill init() method is completly executes servlet does not serve the client request.

--init() method called by WebContainer only once in the whole life of a servlet.
--second client req onwards same servlet instance serves any number of client request.
--as a developer,we write resourse allocaion code in this init() method.
for ex-db conn creation,PreparedStatement obj creation.


2.In order to call second life-cycle method on the servlet object ie.
service(SReq r SRes q) Web-container creates ServletRequest object and 
ServletResponse object and pass those reff as service() method argument.

--when client send a request to AS it sends few information along with the request.
like-ipaddress of client,protocol,request parameter
An object of ServletRequest is used to access those information.
user input of client is accessed by this object bcoz requst parameter value 
of client request can be acess by this object.


---An object of ServletResponse is used to send generated html to client browser.
ie,dynamic page is built and handed over to the WS or AS using response object.

this is done by calling getWriter() method on response obj.
this getWriter() method returns PrintWriter class object.and that object is pointing 
to the ServletResponse object,so the message kept in println() method of PrintWriter
class goes to the response object and this response object handed over to the WS or AS
and server sends this message to browser as webpage.


MIME(mutipupose internet mail Extension)
--servlet can send data other than html also;

--which kind of data we are sending must be specified at the begining by calling 
setContentType();method on the response object by suppliying appropriate MIME type

ex:-
for html--text/html
for json application/json
for xml --application/xml

etc



--Web-container creates these two ServletRequest and ServletResponse and call 
service(req res)method by passing these two object refference.


--one service() method is completly executed means client req is processed and the 
res page is sent.

--now for each req Web-container calls service() method.

3.just before Servlet container marks the servlet object for garbage collection it calls
destroy() method.
--developers use this method to release the allocated resoures

eg-closing the connection,or PS;
--it also called only once in whole life time of servlet.



note:-Servlet is a single instance multiple thread server-side component.that means
 when multiple request are given to a servlet only one object of servlet class will be 
created and multiple threads will be started on that object representing multiple 
request.
each req comming to servlet will execute service() method to process the request.




----A servlet has three names in a web-app
1.Registration name
2.fully qualified class name
3.url-name


purpose of servlet tag in web.xml:-
-----------------------------------
--to register a servlet with web-application and thereby with web-container.

purpose of servlet-mapping tag:-
-----------------------------------
--to give public url name to the servlet,it provides mapping information to web
container which client request should be delegated to which servlet.

--every servlet of a webapplication will be identified with its url-pattern
url-pattern to servlet is mandatory and it is given to avoid servlet class from
outsiders of webapplication.


Develop a servlet example to add two number using servlet interface.
-------------------------------------------


t1=rama,

technically t1 is called request parameter name and rama is request parameter value


Initialization parameter:-
-------------------------


--it is a name value pair of textual information supplied to a servlet as extra
configuration information.
--this initialization parameter is supplied to a servlet by web.xml with the
help of <init-param> tag it is a paired tag
--this <init-param> tag contain two paired child tag
1.<param-name>
2.<param-value>

<servlet>
<sn></sn>
<sc></sc>
<init-param>
<param-name>p1</param-name>
<param-value>scott</param-value>
</init-param>
</servlet>
<sm>
</sm>

---by using <init-param> we can supply n number of textual information to a servlet
as required.


---during ServletConfig obj creation time Web-container encapsulate init-parameters
into ServletConfig obj.

--By calling getInitParameter() method on ServletConfig object init-parameters are 
retrieved in a servlet program.
ex:-String cfg.getInitParameter("p1");


use of init-parameter:-
------------------------

--to supply diff set of value to the servlet at diff time of its execution without 
change of its source code.

--to prevent hard coding of certain data in a servlet.




---String getInitParameter(String name);
--this method takes init parameter name as argument and returns init-parameter value.




Context parameter:-
====================

--if we want to supply some extra textual data to only one servlet by using web.xml then we should use <init-param> tag inside <servlet> tag

where as if we want to supply some extra textual data to all the servlets of a webapplication then we should use <context-param> tag




--we can supply data to a servelt from outside by 3 methods:-


1.by using request parameter (from the browser)

2.by using init parameter (from the web.xml)

3.by using context parameter (from web.xml)



--request parameter values r stored in HttpServletRequest obj

--init parameter values r stored in ServletConfig obj

--context parameter values r stored in ServletContext obj


--ServletContext obj is created by webcontainer at the time of deployement of an webapplication.

that means,when we deploy an webapplication on the webserver,webcontainer creates one ServletContext obj to represent that webapplication.

where as ServletConfig obj is created by the webcontainer at the time of calling first life cycle method i.e init(-) on our servlet class obj.


while creating the ServletConfig obj,container encapsulates the ServletContext obj reff into the ServlerConfig obj.


ServletContext---one per webapplication
ServletConfig----one per servlet


--in a webapplication,there r n number of servlet can be there.and for each servlet container creates ServletConfig obj. and each config obj holds the same ServletContext obj reff.






GenericServlet:-
----------------
exercise on login admin and admin by use of genericServlet if time permitts.

--there are two init() methods are there in GenericServlet class
1.paramiterized init(ServletConfig cfg) that is from Servlet interface.
2.zero agrument init() method.

zero argument init() method has a null body.

--parameterize init() method does two things
1.storing container given ServletConfig object reff in the instance variable of the
GenericServlet class. 
2.call Zero argument init() method.

note:-if we place parameterize init() method in our class container will never going
to call parameterize init() method defined in GenericServlet,
hence we lose the chance of invoking ServletConfig object methods outside of that
init() method.
--so it is always advisible to override zero argument init() method in user defined
servlet class. or call super(config) from constructor of parameterized init.




---GenericServlet implements ServletConfig interface also so that we can call
 methods of ServletConfig interface without its refference.





LoadonStartup:-
==============

<load-on.startup> is a child tag of <servlet> tag in web.xml file


--with the help of this tag we pre-initialize the servlet class before first request.

--here we can pass pos or neg number,here smaller values get the higher priority among multiple servlets and bigger number gets the low priority.

where as passing neg number is equavalent to not using load-on-startup.

--here obj of our servlet will be created and init(-) method is called.




HttpServlet:-
----------------

Superclass has a generalize feature and a Subclass has specialized feature.

A servlet is classified into two categories:-

1.protocol independent

2.Protocol dependent

javax.servlet.GenericServlet is called protocol independent servlet.

---A servlet is meant for not only support http protocol only but to support 
any protocol like,ftp protocol,smtp protocol etc.
---Dynamic content genration is required not only for Http but other protocol also

---if a Servlet is protocol independent it can not support some powerful feature of
http protocol,
ie,session tracking,cookies,url-rewiting,etc.without which no commercial WA
survive.

---therefore user defined servlet should not be protocol independent in order to 
create webapplication.

---javax.servlet.http.HttpServlet is known as protocol dependent Servlet.

---it is recomended that our servlet class should inherit from HttpServlet always.
and write web-page generated logics in doGet() or doPost() method of HttpServlet
class.



---HttpServlet is an abstract class.

---it contains two service() methods
1.public void service(ServletRequest req,ServletResponse res) from GS,from Servlet int
2.protected void service(HttpServletRequest req,HttpServletResponse);

and 8 doxxx() methods.




how doGet() and doPost() is called

---web container calls public service() method,
---this service() method will call protected service() method defined in HttpServlet
---and this protected service() method will calls doGet() or doPost() method

logic in public service() method implemented in HttpServlet class:-
-----------------------------------------------------------------

it does two things:-

1.converting ServletRequest and ServletResponse object into HttpServletRequest
and HttpServletResponse object.
2.calling protected service() method.

ie.

public void service(ServletRequest req,ServletResponse res)
{
HttpServletRequest req=(HttpServletRequest)req;
HttpServletResponse res=(HttpServletResponse)res;

service(req,res);
}

here no recurrsion//bcoz it is calling proteced service() method.

logic in protected service() method in HttpServlet class:-
---------------------------------------------------------

based on the client request method ie.GET or POST 
it will call doGet() and doPost() accordingly by supplying HttpRequest and HttpResponse
obj.


---protected service(), init(), doGet(),doPost() ...they are not a life cycle methods
they are helper methods to the life-cycle method.


making flexible servlet instead of doGet() or doPost()
------------------------------------------------------





Servlet DB communicatio:-
------------------------


Note:--for db servlet comm we have to place jdbc code inside the servlet and 
copy driver releted jar file into lib folder of the application:-



mysql>mysql -u user5 -p


url= "jdbc:mysql://localhost:3306/ratan","root","root"

driver="com.mysql.jdbc.Driver"



String--driver
String--url
String--username
String--pass





Inter-Servlet communication or Servlet Chaining:-
-------------------------------------------------

--In this one Servlet delegate the request processing duty to another servlet.

--Inter-servlet communication is implemented to attend a complex client request.

---We achive inter-servlet comm by RequestDispatcher object.

---By calling getRequestDispatcher() method on the ServletRequest object supplying
other servlet url name with slash as argument we get RequestDispatcher(I) object.
ex:-
ReruestDispatcher rd=req.getRequestDispatcher("/ssrv");here (/) is mandatory


--after getting object of RequestDispatcher dispatch the request to the other servlet
by calling forward() or include() method on the RequestDispatcher object and supplying req,and res obj as argument.

rd.forward(req,res):-forwarding request
or
rd.include(req,res):-Including response


rd.forward(req,res):-
---------------------
--first servlet recieves the client request does some portion of the request processing
and remaining portion of the prosessing sake it delegate the request processing duty
to the other servlet.

--second servlet performs the remaining portion of the processing.
--second servlet is responsible to build the response page and send to the client.
---first servlet genereted output is discarded.



rd.include(req,res):-
--------------------
--first perform same as rd.forward
--second servlet performs the remaining portion of the processing.
--after processing it returns the control to the first servlet.
--output page logic of second servlet is included in in the first servlet at the 
palce where rd.include() is called .  
--here first servlet only is responsible to produce the response page and send to the 
client via server.




Note:-Generally in servlet only forward() mechanism is used.
and in jsp include() mechanism is used.


------------------------------------------second batch--------------
Servlet collaboration:-
----------------------

one servlet assisting other servlet is noting but servlet collaboration.

--servlet collaboration is achieved in two ways:-

1.by sharing controls
2.by sharing data

--through inter-servlet communication sharing control is possible.

--one servlet store data in shared memory location to which other servlet have access
.this is known as one servlet collaborating with other servlet by sharing data.


---Memory location or scope of data:-
-------------------------------------

A data item is said to be request scope if it is stored in HttpServletRequest object.
--when a data item is in request scope it is sharable to those servlets which are 
communicating each other within one req-res cycle.

A data item is said to be in session scope if it is stored in HttpSession object.
--when a data item is in a session scope it is sharable to all the servlet which are 
participating in the same session.

note:-multiple servlet participating in the same session need not communicate one 
another.


A data item is said to be in application scope if it is stored in the ServletContext
object.
--when a data item is in application scope it is sharable to all the servlet of the 
application.

ServletContext object is called as global memory of a web-app.




methods to deal with scoped data:-

they are common in HttpServletRequest,HttpSession and ServletContext.

1.setAttribute(String name,Object value);
2.Object getAttribute(String name);
3.removeAttribute(String name);






sendRedirect():-
---------------

--HttpServletResponse has a method sendRedirect(String url)throws IOException
generates a response status code 302 and sends the passed url to browser.browser
uses that status code and generate request to passed url.

--We cannot use RequestDispatcher object to communicate bt two servlets that are 
available in two diff server.

---for this purpose we have to use sendRedirect(-);//if servlet in same webapp 
without(/) other wise complete url.

---supplied url can be any webresourse prog developed in any technology.
like:-asp,java,php,html etc..



in the sendRedirect("Srv2")---same req,resp cycle will not work.






Jsp:-
----
--jsp is a technology used to create web-application just like Servlet-technology.

--it allow tag based programming...

---A Jsp is also a web comonent.
---it is a html file with the .jsp extention in which we can write java code.

--it contains templete text(html text + Normal text)+and jsp tags.


---it allow to work with all the features of servlet bcoz.for every jsp an equalivent
servlet will generate.

---there are three life-cycle methods are available in jsp equllent servlet
1.jspInit()
2._jspService(hreq,hres)
3.jspDestroy()




---modification done in jsp will be reflected without recompilation and without
reloading of web-app.

--it allows to write html code seperatly without mixing up java code and html tags.

---the location of jsp file is parellal to WEB-INF ie along with html files.
so they can directly accessd by their name..

---it gives support to work with implicit objects ie.built-in object.

--jsp tag names and its attributes are case sensitive.

---there are 2 types of objects are there in jsp programming:-

1.implicit object
2.Explicit or user-defined object

implicit object:-
-----------------
All the implicit objects are well instantiated and readly avaliable in jsp.
so programer can use these obj in jsp without creating them explictly and without 
writing code to access them:-
request
response
page//current class object.
pageContext
config
application //ServletContext
out //from JspWriter simmilar to printWriter,used to send output to client.
exception
session

Explicit object:-
----------------
programer created object:-

ex-
String s=new String("ok");
Date d=new Date();


---in the process of executing a jsp there will be two phase:-

1.Translation phase:-
2.Request Processing phase:-

--in translation phase there will be a page comipler that converts jsp file into 
eqallint servlet then from servlet source code java compiler gives .class file of
jsp eqaullivent servlet.(welcome.jsp to welcome_jsp.java)

---in request processing phase _jspService() of jsp equllent servlet will be executed
and generated output goes to client.

t-phase:-.jsp-->.java-->.class

there are 4 types of tags in jsp programming:-

1.Scripting tag:-are given to place java code in jsp
----------------

this tag is further divided into 3 type:-

a.scriptlet:-<% ---- %>
--java code placed in the scriptlet goes to the _jspService() of the jsp eqq servlet.
--variable decleared in scriptlet will act as local variable of _jspService().
--in one jsp we can have multiple scriptlets,the code placed in these scriptlets 
goes to _jspService() only.
--generally we place request processing logic and response generation logic in the 
scriptlet tag.
--dont place user-defined method defination in scriptlets
becoz this method deff code goes as it is to the _jspService() and become nested 
method diffenation.
--all implicit object we can use in scriplet tag only..

b.declaration:-<%! ---- %>

--we use this tag to declare instance variable
--define a user defined method .
ex:-
<%! int i=10 %>
here i comes as instance varibale of jsp eqq servlet.

--in order to place the other two life cycle method having initialization and uninit
logic we need to take support of declaration tag..



c.Expression:-<%= --- %>
--this tag is given to evaluate the given experation and to send generated result to 
browser as response.
--the code placed in expression tag comes to -jspService() method only.
--we generally use expression tag to display variable values.

ex:-

<%! int a=10; %>
A value is <%= a %>

--we can use expression tag to call both user-diff and pre-diff methods
<%! public int sum(int x,int y)
{
return x+y;
} %>

the sum is:<%= sum(10,20) %>

--expression tag can evaluate only one expression at a time.
ie:-
result is:<%= a+b,b+c %> wrong code.
--one jsp program can utilize expression tag for n no of times.
--we can't use an expression tag inside scriptlet and decleration tag and vise-versa

---------------------------------first batch---------------------------------


2.jsp comment tag:-
---------------------
<%-- ----  --%>

3.Directive tags:-are given to direct or guide the page compiler or provide global information to jsp page compiler.
-----------------


syntax:-<%@directive attribute="value"%>or<%directive attribute1="value" attribute2="value2"%>

a.page directive:-<@page attributes= %>
--it is used to provide global details and global information to jsp page like,
import="java.util.*,java.util.util.*"//most usefull
language="java"
contentType="text/html"
isThreadSafe="true"
session=true
buffer="32kb"
autoflash="true"
extends="com.myclass"
errorPage=""
isErrorPage="true"



b.include directive:-<@include attributes %>
--it includes the code of destination webresourse in the jsp eqllservlet code.
--attribute name is file.
--recomended to use when destination resource is static resourse.
ex:-<@include file="b.html" %>

c.taglib directive:-<@taglib attributes %>

4.Standard Action tag:-
----------------------
--they never become part of genereted servlet of jsp page...
--business logics can be codded in action tag and it bocome reusable...
some of the tags are:-

<jsp:forward>
<jsp:include>
<jsp:useBean>
<jsp:setProperty>
<jsp:getProperty>





jsp to bean communication:-
---------------------------

---any thing in Object oriented programming which is reusable is called Bean.

--We use <jsp:useBean> tag to instruct the container to create bean class object.

<jsp:useBean id="st" class="p1.student" scope="session"/>

---<jsp:setPropery> tag is used to populate the bean feilds.
<jsp:setProperty name="st" property="sno" value="567"/>
--if we want to supply user input value from browser to beanfeild,
instead of "value" attribute we have to pass "param" attribute, and value should be
req-parameter name.
ex:-
<jsp:setProperty name="st" property="sno" param="stno"/>//from form field


--if req-parameter name and bean-field name is same then with single use of setPropery
tag,all the bean feild can be populated.
ex:-<jsp:setProperty name="st" property="*"> 

-----to retrieve the bean feild value and write to the browser stream we use
<jsp:getProperty> tag.
ex:-
Name is:<jsp:getProperty name="st" property="sname"/>




****more jsp from jsp2 notes:-













Session Tracking:-
------------------
session:-
set of continious releted req res operations performed on the web-page by end-user 
from a browser window is called a session.ie make web-app remembering client data
across multiple request to web-app.
--
we achive session-tracking by following technique:-
1.hidden-form feilds
2.Cookies.
3.HttpSession
4.url-rewriting.



Hidden form fields:-
--------------------

<input type="hidden">

a.jsp:-
------


<form action="b.jsp" method="get">


Enter First name:<input type="text" name="fname"><br>
<input type="submit" value="go">

</form>


b.jsp:-
--------


<form action="result.jsp" method="get">

<input type="hidden" name="fname" value=<%=request.getParameter("fname") %>>

Last name :<input type="text" name="lname">
<input type="submit" value="done">


</form>




result.jsp:-
------------



<h1>Welcome <%=request.getParameter("fname")+" "+request.getParameter("lname") %> </h1>











Cookies:-
---------

---it is a name-value pair of textual-information which allocates memory at client
machine and remembers client data across multiple request,

--cookies allocate memory at client side but they travel over the network along with 
Http request and Http respone object.

--A cookie is created programatically by dynamic WR program.

--every cookie is identified with its cookie id.

Note:-every cookie remembers the name of the web-app from which this cookie belongs to..

--cookie goes to the client along with the response of web-resource program as 
'set-cookie' respone header value.

--cookie come back to the web-app along with the request from browser as request-header
called 'cookies' value .

--one browser window can contain cookie belonging to multiple web-app.

Note:- cookie belonging to one web-app will go back that web-app only,when browser window give request back to that web-app.

note:-every cookie created in server side program must be added in response object 
mannually.


---there are two types of cookie: 

1.Session cookie:-
-these cookie allocate memory on b/w window without
expiry time, so these cookie will be destroyed automattically once b/w win is closed

cookie c=new Cookie("op","hyd");
res.addCookies(c);



2.persistent cookie:-
these cookie allocates memory on file system of client machine in the form of files 
having expiry time,
so these cookie will be destroyed only when their expiry time is completed.

cookie c=new Cookie("op","hyd");
c.setMaxAge(1800)//sec.
res.addCookies(c);


to read the cookie:-

Cookie ck[]=req.getCookies();

if(ck !=null)
{
for(int i=0;i<ck.length;i++)

{
pw.println(ck[i].getName()..........ck[i].getValue());
}
}

//it can not store java obj as value;it can store only text values.








ex:-


a.jsp:-
----------
<body>

<%

String u="";
String p="";

Cookie ck[]=request.getCookies();

if(ck != null)
{
	for(Cookie c:ck){
		if(c.getName().equals("username"))
			u=c.getValue();
		if(c.getName().equals("password"))
			p=c.getValue();
}

}

%>



<form action="Srv" method="post">


Enter Username <input type="text" name="usr" value="<%=u %>"><br>

Enter Password <input type="password" name="pass" value="<%=p %>"><br>
<input type="submit" value="login">

</form>

</body>




Srv.java:-
-----------


protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		
		String usr=request.getParameter("usr");
		String pass=request.getParameter("pass");
		
		String page="fails.jsp";
		
		
		if(usr.equals(pass)){
			page="welcome.jsp";
			
			Cookie ck1=new Cookie("username", usr);
			Cookie ck2=new Cookie("password", pass);
			
			ck1.setMaxAge(3600*24);
			ck2.setMaxAge(3600*24);
			
			response.addCookie(ck1);
			response.addCookie(ck2);			
		}
		
		response.sendRedirect(page);
		
	}














HttpSession:-
---------------

HS is an object created by the webcontainer to represent first client request, this obj allocates memory on the WS and "it is specific to one b/w window".



-Every HS object contains an unique id called JSESSIONID.based on this id the session obj will be identified,accross the multiple req that are comming to web-app during a session from same browser window.


Note:-this JSESSIONID and its value normally travel with http-requset header and http-respone header as cookies.


--when we give first req to our webapplication from the browser,that req carries no any session id(JSID) by the "http-requset header" cookies, 

--for that req, servlet-container creates one obj called HttpSession obj with a unique id called JSESSIONID as name and a unique value for it.

--as a programmer we get reff of this obj and can keep any value on this obj.
by

HttpSession ses=request.getSession();
ses.setAttribute("empname","rama");






--when server sends the response back to the browser,that id and its value will go back to the browser by HTTP-respose(as Http-response header "set-cookie" here cookie name will be JSESSIONID and value will be that unique value).




--now if from the same browser if we give the 2nd request to our webapplication, this time 2nd request carries that JSESSIONId and its value by HTTP-request(as http-request header cookies) and with this id webserver identify the previously created HttpSession obj and return the reff of that obj only.
when we call

request.getSession() method

so any value kept in that session obj will be availabe for this request also.(i.e we make our web-application remembering the privious request data) 
 

--for another requset from diff browser no any cookies value (JSESSIONID) goes to  our webapplication. for that request,our webserver creats another HttpSession obj with diff JSESSIONID and diff value.

now if we try to call

request.getSession() method we will get newly created session obj where no any value is kept. so our session tracking fails




methods To get access to HS object:-
--------------------------------------

Hs ses=req.getSession();//

if session obj is already availabe get that old session obj oterwise get the obj of newly created session obj.

Hs ses=req.getSession(true);//same

Hs ses=req.getSession(false);//if already avalible then only get that old session obj,otherwise return null value(don't return newly created session obj).


--to check whether a session is newly created session or not:-
sess.isNew();


--to inactive session obj call
ses.invalidate();//once b/w closed 


--to set a specific time for a session obj:-

sess.setMaxInactiveInterval(int second)


---------




URL-rewriting:-
==============


--this approch we follows to track the session even if the cookies r disabled in the browser..

--in this approch we append the JSessionID and its vlaue to the response obj and send this JsessionId and it value through http-response obj.


ex:-
-----

index.jsp
----------

<body>

<a href="Srv">Click</a>

</body>


Srv.java:-
----------

protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
			
	request.getSession().setAttribute("msg", "Hello Welcome to MySrvlet");
		
		String s=response.encodeURL("output.jsp");
		
		System.out.println(s);
		response.sendRedirect(s);
		
	}



output.jsp:-
------------

<body>

<%Object o=session.getAttribute("msg"); 

if(o != null)
{
	String m=(String)o;
%>

<h1>The message is :<%=m %></h1>


<%}else{ %>

<h1>Session fails...</h1>
<%} %>
</body>













DynamicServlet Registration:-
============================



we can configure a servlet in java web-applicaiton in 3 ways:-

1.using xml (web.xml) file,(outdated)

2.using annotation (@WebServlet).from servlet 3.x

3.using dynamic registration(ServeltContainerInitializer) from servlet 3.x.



--using @WebServlet annotation is frequently used approch but it has a limitaiton that we can not apply this annotation on predefined or third party supplied Servlet classes like DispatcherServlet(Spring MVC),FaceServlet(JSF) etc..to overcome this problem we use dynamic registraion of servlet.


--for this approach we need to use "javax.servlet.ServletContainerInitializer"(I) and implements its one abstract method:-

	public void onStartup(Set<Class<?>> set, ServletContext ctx)throws ServletException 
 

step to dynamic register a servlet class without web.xml and without using @WebServlet annotation.


step 1:- 

create a servlet by implmenting HttpServlet,don't use @WebServlet annotation for mapping.

ex:-



package p1;

import java.io.IOException;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class Srv1 extends HttpServlet {

	

	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		System.out.println("inside Srv1");
	}

	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		doGet(request, response);
	}

}









step2:- 

--create a userdefind class by implementing javax.servlet.ServletContainerInitializer interface and override onStartup(--) method. and provide mapping information to the above servlet:-

 

ex:-


package p2;

import java.util.Set;

import javax.servlet.ServletContainerInitializer;
import javax.servlet.ServletContext;
import javax.servlet.ServletException;
import javax.servlet.ServletRegistration;

import p1.Srv1;

public class SrvInit implements ServletContainerInitializer{

	@Override
	public void onStartup(Set<Class<?>> set, ServletContext ctx)
			throws ServletException {
		
		/*Srv1 srv=new Srv1();
		
	ServletRegistration.Dynamic reg=ctx.addServlet("test", srv);//test is the any logical name
	reg.addMapping("/testurl");
		
	*/

	ctx.addServlet("anyname", Srv1.class).addMapping("/testurl");
		
	//here we can use loadOnStartup as well we can pass initparam also.
	//reg.setLoadOnStartup(1);
	//reg.setInitParameter("dname", "oracleDriver");
		

	//and in our Servlet we can get this init-param from config obj.		
	
		
	}

}





step 3:-

create a text file with name:-

javax.servlet.ServletContainerInitializer under a folder META-INF/services/ folder


ex:-


myapp/META-INF/services/javax.servlet.ServletContainerInitializer


here myapp is a normal folder created on desktop inside that META-INF folder,inside that services folder and inside that a file by name javax.servlet.ServletContainerInitializer.

--in that file write the fully qualified name of the ServletContainerInitializer implemented class.


ex:-


javax.servlet.ServletContainerInitializer:-
-------------------------------------------

p2.SrvInit




step 4:- save this file and create the jar file for the above file:-


ex:-


myapp>jar -cvf ab.jar .




step 5:- copy the above created jar file from myapp folder and paste it in WEB-INF/lib folder of our webapplication.


step 6 :- give the request to the servler using "testurl".





Servlet url patterns (exact match,directory match,extension match):-
===================================================================

--to a single servlet we can have diff url-patterns.

in web.xml,by using defferent <servlet-mapping> tags

in @WebServlet({"Srv1","Srv2"})

in ServletInitializer by calling methods.




In Servlet Specification there r three types of Url pattern r* there:-

1.Exact match

2.directory match

3.extension match


--url pattern r given to hide to underlying servlet name from outsiders..

--if we try to give any other than above mentioned url-pattern or mixed url pattern ,then our deployment will fails and it generates error in server.


1.Exact match:- 
---------------

--must start with "/" and should not have spacial charcter as first charecter after "/" but in middle and at end it can have any special charecter * as well 

ex:-

/x/y*---valid

/x/y*p---valid



2.directory match:-
-------------------

--must start with "/" and must end with "/*" symbol.

ex:-

/x/y/*--valid

/*----valid





3.extention match:-
-------------------

--must start with * symbol and ends with extension word or latters.

--should not start with "/".

ex:-

*.do







****front controller Design pattern and MVC2:-
==============================================



--initially java-web appl development started with Servlet and we used to define the entire business processing and presentation logic on the data in the servlet itself.





browser----> servlet---------------->DB
		|
	--captures the user input
	--validation
	--business processing
	--data-manipulation
	--presentation logic
	


--As a number of clients r increased to the Servlet,the burden on the Servlet is also got increased,so we used to develop appl with Servlet and java bean components with DAO pattern.

--A bean(java class) performs business processing with DB manipulation and Servlet handles presentation on Data.


--actually,in DAO pattern we don't perform b.logic processing,for that we need some java bean class(either EJB,SpringBean,normal java beans)normal java bean class can have b.logics also.





browser<----->Servlet<------------------>bean---------------------------->DB
		|			   |
	--captures the user-input	--data processing
	--validations			--data manipulation
	--presentation		




--the web-app that used to develped with Servlet or 'Servlet with bean' combination r called 'model-1' web-appl.





--when JSP technology introduced in the market,Model-2 web-appl development started.

--'Model 2' web-app r called MVC,in this,Servlet and JSP and Bean is used to develop the web-appl.

--In bean,business processing and DB manipulations r done and in JSP presentation on the Data is defined.In Servlet,the control flow logic is defined to manage beans and jsps.



***--in MVC,Model is a bean which contains business logic,View is a jsp or some other view technology which contains presentation logic and a Controller is a Servlet which manages the Models and Views.


Adv of MVC:-
------------

--seperate the PL from BLL and DAL with the help of controller(Servlet) ,it leads to better code maintence and development,parellal development is possible.



--MVC is started as Design-pattern,latter it is made as a standard Model for web-appl Development with both java and non-java technology.



--the main objective of MVC is to provide loose coupling bt business and Prsentation logic of application.


--Better performance..



Disadvantage of MVC architecture:-
==================================

--for a larger application,for each client requirement(use-case) we need a seperate controller.


MVC2 architecture:-
===================


--to overcome the above limitation,MVC2 architecture is proposed after refining the mvc1 architecture,according to this Design pattern,
for entire application only one contoller will be there which will act as a FrontController and this frontcotrller will be a servlet program,

--this frontcontroller will only trap all the request for an application for any use-case,and it takes the support for an helper controller class(abstract controller).

--here abstract controller will perform req processing duty by using the help of Bean and DAo class and  

reffer MVC2.jpg in spring/rbs folder



--by manual approach we can use this pattern but we have to write this frontcontroller class, handlermapping,and abstract controllers,and lots of configuration.

-so,there r lots of readymade f/ws r available in the market to implement MVC2 pattern based web-application.

those are:-


Struts from apache foundation

JSF from Sun/Oracle 

Spring-MVC from interface21.


Rules of MVC2 architecture:-
============================



1.in mvc-2 architecture every layer is designed to place a specific logic,just add only those logics in that layer and don't place any other extra logics.

2.All the operations and execution in web-app must takes place under the monitoring and control of controller Servlet.

3.view layer resource must not talk with model layer components directly and vice-varsha,they must intract each other through controller servlet.(two jsps should not intract each other directly,they must intract through ControllerServlet).


4.there can be multiple resources(jsp programs) in view layer and there can be multiple resources(b.comp) in model layer but there must be only one servlet program in controller layers acting as controller servlet.

5.Client can not directly access other any view resource(jsps) other than index.jsp file.
(so only one entry point should be there for entire application).




 






























